// -------------------------------------------------------------
// 
// File Name: hdlsrc\Fixed\CALC_MAGNITUDE_AND_PHASE_FIXED_POINT.v
// Created: 2023-01-16 16:18:56
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// o_PHASE                       ce_out        1
// o_VALID                       ce_out        1
// o_MAGNITUDE                   ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: CALC_MAGNITUDE_AND_PHASE_FIXED_POINT
// Source Path: Fixed/CALC_MAGNITUDE_AND_PHASE_FIXED_POINT
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module CALC_MAGNITUDE_AND_PHASE_FIXED_POINT
          (i_CLK,
           i_RST_N,
           i_CLK_EN,
           i_COMPLEX_VALUE_re,
           i_COMPLEX_VALUE_im,
           i_VALID,
           ce_out,
           o_PHASE,
           o_VALID,
           o_MAGNITUDE);


  input   i_CLK;
  input   i_RST_N;
  input   i_CLK_EN;
  input   signed [32:0] i_COMPLEX_VALUE_re;  // sfix33_En21
  input   signed [32:0] i_COMPLEX_VALUE_im;  // sfix33_En21
  input   i_VALID;
  output  ce_out;
  output  signed [15:0] o_PHASE;  // sfix16_En13
  output  o_VALID;
  output  signed [32:0] o_MAGNITUDE;  // sfix33_En21


  wire enb;
  wire signed [32:0] Atan2_out1;  // sfix33_En30
  wire signed [15:0] Data_Type_Conversion_out1;  // sfix16_En13
  reg signed [15:0] delayMatch_reg [0:10];  // sfix16 [11]
  wire signed [15:0] delayMatch_reg_next [0:10];  // sfix16_En13 [11]
  wire signed [15:0] Data_Type_Conversion_out1_1;  // sfix16_En13
  reg  [0:33] delayMatch1_reg;  // ufix1 [34]
  wire [0:33] delayMatch1_reg_next;  // ufix1 [34]
  wire i_VALID_1;
  wire signed [65:0] Product_mul_temp;  // sfix66_En42
  wire signed [64:0] Product_out1;  // sfix65_En42
  wire signed [65:0] Product1_mul_temp;  // sfix66_En42
  wire signed [64:0] Product1_out1;  // sfix65_En42
  wire signed [65:0] Add_add_cast;  // sfix66_En42
  wire signed [65:0] Add_add_cast_1;  // sfix66_En42
  wire signed [65:0] Add_out1;  // sfix66_En42
  wire signed [32:0] Sqrt_out1;  // sfix33_En21


  atan2_cordic_nw u_Atan2_inst (.i_CLK(i_CLK),
                                .i_RST_N(i_RST_N),
                                .enb(i_CLK_EN),
                                .y_in(i_COMPLEX_VALUE_im),  // sfix33_En21
                                .x_in(i_COMPLEX_VALUE_re),  // sfix33_En21
                                .angle(Atan2_out1)  // sfix33_En30
                                );

  assign Data_Type_Conversion_out1 = Atan2_out1[32:17];



  assign enb = i_CLK_EN;

  always @(posedge i_CLK or posedge i_RST_N)
    begin : delayMatch_process
      if (i_RST_N == 1'b1) begin
        delayMatch_reg[0] <= 16'sb0000000000000000;
        delayMatch_reg[1] <= 16'sb0000000000000000;
        delayMatch_reg[2] <= 16'sb0000000000000000;
        delayMatch_reg[3] <= 16'sb0000000000000000;
        delayMatch_reg[4] <= 16'sb0000000000000000;
        delayMatch_reg[5] <= 16'sb0000000000000000;
        delayMatch_reg[6] <= 16'sb0000000000000000;
        delayMatch_reg[7] <= 16'sb0000000000000000;
        delayMatch_reg[8] <= 16'sb0000000000000000;
        delayMatch_reg[9] <= 16'sb0000000000000000;
        delayMatch_reg[10] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
          delayMatch_reg[5] <= delayMatch_reg_next[5];
          delayMatch_reg[6] <= delayMatch_reg_next[6];
          delayMatch_reg[7] <= delayMatch_reg_next[7];
          delayMatch_reg[8] <= delayMatch_reg_next[8];
          delayMatch_reg[9] <= delayMatch_reg_next[9];
          delayMatch_reg[10] <= delayMatch_reg_next[10];
        end
      end
    end

  assign Data_Type_Conversion_out1_1 = delayMatch_reg[10];
  assign delayMatch_reg_next[0] = Data_Type_Conversion_out1;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];
  assign delayMatch_reg_next[5] = delayMatch_reg[4];
  assign delayMatch_reg_next[6] = delayMatch_reg[5];
  assign delayMatch_reg_next[7] = delayMatch_reg[6];
  assign delayMatch_reg_next[8] = delayMatch_reg[7];
  assign delayMatch_reg_next[9] = delayMatch_reg[8];
  assign delayMatch_reg_next[10] = delayMatch_reg[9];



  assign o_PHASE = Data_Type_Conversion_out1_1;

  always @(posedge i_CLK or posedge i_RST_N)
    begin : delayMatch1_process
      if (i_RST_N == 1'b1) begin
        delayMatch1_reg[0] <= 1'b0;
        delayMatch1_reg[1] <= 1'b0;
        delayMatch1_reg[2] <= 1'b0;
        delayMatch1_reg[3] <= 1'b0;
        delayMatch1_reg[4] <= 1'b0;
        delayMatch1_reg[5] <= 1'b0;
        delayMatch1_reg[6] <= 1'b0;
        delayMatch1_reg[7] <= 1'b0;
        delayMatch1_reg[8] <= 1'b0;
        delayMatch1_reg[9] <= 1'b0;
        delayMatch1_reg[10] <= 1'b0;
        delayMatch1_reg[11] <= 1'b0;
        delayMatch1_reg[12] <= 1'b0;
        delayMatch1_reg[13] <= 1'b0;
        delayMatch1_reg[14] <= 1'b0;
        delayMatch1_reg[15] <= 1'b0;
        delayMatch1_reg[16] <= 1'b0;
        delayMatch1_reg[17] <= 1'b0;
        delayMatch1_reg[18] <= 1'b0;
        delayMatch1_reg[19] <= 1'b0;
        delayMatch1_reg[20] <= 1'b0;
        delayMatch1_reg[21] <= 1'b0;
        delayMatch1_reg[22] <= 1'b0;
        delayMatch1_reg[23] <= 1'b0;
        delayMatch1_reg[24] <= 1'b0;
        delayMatch1_reg[25] <= 1'b0;
        delayMatch1_reg[26] <= 1'b0;
        delayMatch1_reg[27] <= 1'b0;
        delayMatch1_reg[28] <= 1'b0;
        delayMatch1_reg[29] <= 1'b0;
        delayMatch1_reg[30] <= 1'b0;
        delayMatch1_reg[31] <= 1'b0;
        delayMatch1_reg[32] <= 1'b0;
        delayMatch1_reg[33] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
          delayMatch1_reg[3] <= delayMatch1_reg_next[3];
          delayMatch1_reg[4] <= delayMatch1_reg_next[4];
          delayMatch1_reg[5] <= delayMatch1_reg_next[5];
          delayMatch1_reg[6] <= delayMatch1_reg_next[6];
          delayMatch1_reg[7] <= delayMatch1_reg_next[7];
          delayMatch1_reg[8] <= delayMatch1_reg_next[8];
          delayMatch1_reg[9] <= delayMatch1_reg_next[9];
          delayMatch1_reg[10] <= delayMatch1_reg_next[10];
          delayMatch1_reg[11] <= delayMatch1_reg_next[11];
          delayMatch1_reg[12] <= delayMatch1_reg_next[12];
          delayMatch1_reg[13] <= delayMatch1_reg_next[13];
          delayMatch1_reg[14] <= delayMatch1_reg_next[14];
          delayMatch1_reg[15] <= delayMatch1_reg_next[15];
          delayMatch1_reg[16] <= delayMatch1_reg_next[16];
          delayMatch1_reg[17] <= delayMatch1_reg_next[17];
          delayMatch1_reg[18] <= delayMatch1_reg_next[18];
          delayMatch1_reg[19] <= delayMatch1_reg_next[19];
          delayMatch1_reg[20] <= delayMatch1_reg_next[20];
          delayMatch1_reg[21] <= delayMatch1_reg_next[21];
          delayMatch1_reg[22] <= delayMatch1_reg_next[22];
          delayMatch1_reg[23] <= delayMatch1_reg_next[23];
          delayMatch1_reg[24] <= delayMatch1_reg_next[24];
          delayMatch1_reg[25] <= delayMatch1_reg_next[25];
          delayMatch1_reg[26] <= delayMatch1_reg_next[26];
          delayMatch1_reg[27] <= delayMatch1_reg_next[27];
          delayMatch1_reg[28] <= delayMatch1_reg_next[28];
          delayMatch1_reg[29] <= delayMatch1_reg_next[29];
          delayMatch1_reg[30] <= delayMatch1_reg_next[30];
          delayMatch1_reg[31] <= delayMatch1_reg_next[31];
          delayMatch1_reg[32] <= delayMatch1_reg_next[32];
          delayMatch1_reg[33] <= delayMatch1_reg_next[33];
        end
      end
    end

  assign i_VALID_1 = delayMatch1_reg[33];
  assign delayMatch1_reg_next[0] = i_VALID;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];
  assign delayMatch1_reg_next[3] = delayMatch1_reg[2];
  assign delayMatch1_reg_next[4] = delayMatch1_reg[3];
  assign delayMatch1_reg_next[5] = delayMatch1_reg[4];
  assign delayMatch1_reg_next[6] = delayMatch1_reg[5];
  assign delayMatch1_reg_next[7] = delayMatch1_reg[6];
  assign delayMatch1_reg_next[8] = delayMatch1_reg[7];
  assign delayMatch1_reg_next[9] = delayMatch1_reg[8];
  assign delayMatch1_reg_next[10] = delayMatch1_reg[9];
  assign delayMatch1_reg_next[11] = delayMatch1_reg[10];
  assign delayMatch1_reg_next[12] = delayMatch1_reg[11];
  assign delayMatch1_reg_next[13] = delayMatch1_reg[12];
  assign delayMatch1_reg_next[14] = delayMatch1_reg[13];
  assign delayMatch1_reg_next[15] = delayMatch1_reg[14];
  assign delayMatch1_reg_next[16] = delayMatch1_reg[15];
  assign delayMatch1_reg_next[17] = delayMatch1_reg[16];
  assign delayMatch1_reg_next[18] = delayMatch1_reg[17];
  assign delayMatch1_reg_next[19] = delayMatch1_reg[18];
  assign delayMatch1_reg_next[20] = delayMatch1_reg[19];
  assign delayMatch1_reg_next[21] = delayMatch1_reg[20];
  assign delayMatch1_reg_next[22] = delayMatch1_reg[21];
  assign delayMatch1_reg_next[23] = delayMatch1_reg[22];
  assign delayMatch1_reg_next[24] = delayMatch1_reg[23];
  assign delayMatch1_reg_next[25] = delayMatch1_reg[24];
  assign delayMatch1_reg_next[26] = delayMatch1_reg[25];
  assign delayMatch1_reg_next[27] = delayMatch1_reg[26];
  assign delayMatch1_reg_next[28] = delayMatch1_reg[27];
  assign delayMatch1_reg_next[29] = delayMatch1_reg[28];
  assign delayMatch1_reg_next[30] = delayMatch1_reg[29];
  assign delayMatch1_reg_next[31] = delayMatch1_reg[30];
  assign delayMatch1_reg_next[32] = delayMatch1_reg[31];
  assign delayMatch1_reg_next[33] = delayMatch1_reg[32];



  assign o_VALID = i_VALID_1;

  assign Product_mul_temp = i_COMPLEX_VALUE_re * i_COMPLEX_VALUE_re;
  assign Product_out1 = Product_mul_temp[64:0];



  assign Product1_mul_temp = i_COMPLEX_VALUE_im * i_COMPLEX_VALUE_im;
  assign Product1_out1 = Product1_mul_temp[64:0];



  assign Add_add_cast = {Product_out1[64], Product_out1};
  assign Add_add_cast_1 = {Product1_out1[64], Product1_out1};
  assign Add_out1 = Add_add_cast + Add_add_cast_1;



  Sqrt u_Sqrt (.i_CLK(i_CLK),
               .i_RST_N(i_RST_N),
               .enb(i_CLK_EN),
               .din(Add_out1),  // sfix66_En42
               .dout(Sqrt_out1)  // sfix33_En21
               );

  assign o_MAGNITUDE = Sqrt_out1;

  assign ce_out = i_CLK_EN;

endmodule  // CALC_MAGNITUDE_AND_PHASE_FIXED_POINT

